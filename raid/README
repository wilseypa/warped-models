
Authors: Christopher H. Young, Radharamanan Radhakrishnan Philip A. Wilsey
Computer Architecture Design Laboratory
Dept of ECECS, PO Box 210030
Cincinnati, OH  45221--0030

Copyright 1995--1999 The University of Cincinnati. All ights reserved.  

Published by the University of Cincinnati
Dept of ECECS, PO Box 210030
Cincinnati, OH  45221--0030 USA 

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.


Introduction

This document describes the RAID-5 Disk Array application model that is
distributed with the warped project. RAID Disk Arrays are a method
that provides a vast array of storage by using a Redundant Array of
Inexpensive Disks to provide storage with a higher I/O performance than
several large expensive disks.  This application incorporates a flexible
model of a RAID Disk Array using any one of three possible disk drives.
This application can be configured in various sizes of disk arrays to be
studied. 

The RAID simulation model models the interactions of several processes
with a level 5 RAID Disk Array composed of one of 3 possible disks,
namely:
a Lighting Disk modeled after the IBM 0661 3.25 inch SCSI disk drive
a Fujitsu disk M2652H/S 5.25 inch 1.8GB SCSI, and
a future disk that is an extrapolation from the Fujitsu disk's parameters. 

Explanations of these disks and their parameters can be found in the
SIGMETRICS '93 and ASPLOS '91 papers by Lee and Katz.

The program provided in the warped distribution creates a RAID
simulation with the simulation objects distributed uniformly among the
LPs. This program creates and partitions an arbitrarily sized simulation
of processes, forks, and disks. A configuration file (described below)
is used to control the generation of simulation objects and the number
of requests issued by the source processes to the disks.


RAID Configuration

The RAID configuration file contains the parameters for the RAID
simulation in the following order:

The number of source processes to generate the requests,
The number of fork processes to route the request, 
The number of disks in the disk array,
The number of tokens to be generated by each process,
The type of the disks.


The descriptions of the entries for the config file are:
"Number of Disks d" "Number of Forks f" "Number of Processes p"

"Name of Disk 1" "Type"
...
"Name of Disk d" "Type"

"Name of Fork 1" "Number of output Disks" "Disk Output Names" "Number of start Disk"
...
"Name of Fork f" "Number of outputs Disks" "Disk Output Names" "Number of start Disk"

"Name of Process 1" "Name of output fork" "Disk Type" "Maximum number of requests" "Number of start disk"
...
"Name of Process p" "Name of output fork" "Disk Type" "Maximum number of requests" "Number of start disk"


Example RaidDefault configuration file:
=======================
4 2 2
Disk1 FUJITSU
Disk2 FUJITSU
Disk3 FUJITSU
Disk4 FUJITSU
Fork1 4 Disk1 Disk2 Disk3 Disk4 1
Fork2 4 Disk1 Disk2 Disk3 Disk4 1
Source1 Fork1 FUJITSU 6005 1
Source2 Fork2 FUJITSU 6009 1


RAID Processes

A process generates requests for the RAID Array.  Each request is for a
stripe of random access type (r/w), length, and location.  After sending
the message, the process is assumed to be suspended until all of the
request messages (including parity requests) are received.  After all
messages have been received then the process generates a new request
after some random delay.

The process requires the following information to be passed into its
constructor:

string &myName, string &outName, int maxdisks, DISK_TYPE disk, int maxrequests, int firstdisk, double initSeed

A name string.
The name of a fork to process its requests.
The number of disks in the simulation.
The type of disks in the RAID array.
The number of requests it should generate.
The first disk to send to.
The seed for random generation.


RAID Forks

A fork takes a request from a source process and breaks it up into
individual requests for each disk of the array, calculates the number of
parity requests that are needed, and forwards these requests to the
disks.  A fork will first calculate the number of parity requests that
are needed by calculating the parity destination for each request.
Duplicate requests are found by comparing the parity request for the
current message to the request for the last message.

The current model is for a RAID Level 5 Disk Array with left--symmetric
parity placement.  RAID Level 5 distributes the parity information
across the disk array, so no disk contains the entire parity
information.  The left--Symmetric parity placement policy places the
parity information for the n parity stripes units in a round--robin
fashion starting from the last disk.  An example for 4 disks is shown
below.

| 0  | 1  | 2  | P  |
| 3  | 4  | P  | 5  |
| 6  | P  | 7  | 8  |
| P  | 9  | 10 | 11 |
| 12 | 13 | 14 | P  |

Each number represents a stripe unit, and P represents parity
information.  Each row represents a stripe of data along with the parity
information.  Each column represents the data on a single disk.

The fork requires the following information to be passed into its
constructor:
A name string. 
The number of disks in the simulation.
The names of the disks.
The id of the first disk in the simulation.


RAID Disks

A Disk takes the request and seeks to the proper cylinder using a model
of the seek time calculated found in the papers by Lee and Katz.  The
current model ignores the sector information and assumes that half the
time of a single rotation is needed to position for the sector to appear
under the head.

The disk requires the following information to be passed into its
constructor:
A name string. 
The type of disk to be simulated.



Acknowledgements
This research has been conducted with the participation of many
investigators.  While not an complete list, the following individuals
have made notable direct and/or indirect contributions to this effort
(in alphabetical order):
Perry Alexander,
Scott Bilik,
Harold Carter,
Dale E. Martin,
David A. Charley,
Girindra D. Sharma,
Praveen Chawla,
Debra A. Hensgen
John Hines,
Balakrishnan Kannikeswaran,
Venkatram Krishnaswamy,
Lantz Moore,
Avinash Palaniswamy,
John Penix,
Radharamanan Radhakrishnan,
Dhananjai Madhava Rao, and
Raghunandan Rajan.

We wish to express our sincerest gratitude for the time that you spent
reviewing and commenting on our designs.


This research was supported in part by the Advanced Research Projects
Agency, monitored by the Department of Justice under contract number
J--FBI--93--116.  In addition, we benefited greatly from the technical
support and guidance by the ARPA and DOJ program managers, notably: Bob
Parker, John Hoyt, and Lt. Col. John Toole.  Without this support and
interaction, the work documented in this report would not have been
possible.  Thank you.
